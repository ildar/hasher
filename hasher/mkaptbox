#!/bin/bash -ef
#
# The mkaptbox utility for the hasher project.
#
# Copyright (C) 2003-2022  Dmitry V. Levin <ldv@altlinux.org>
# Copyright (C) 2006  Alexey Gladkov <legion@altlinux.org>
# Copyright (C) 2007  Alex V. Myltsev <avm@altlinux.org>
# All rights reserved.
#
# SPDX-License-Identifier: GPL-2.0-or-later
#

. hsh-sh-functions

show_help()
{
	cat <<EOF
mkaptbox - create initial aptbox in specified working directory.

Usage: $PROG [options] [<path-to-workdir>]

<path-to-workdir> must be valid writable directory.

Options:
  --apt-config=FILE         path to custom apt.conf file;
  --apt-prefix=DIR          path to apt directory prefix (e.g. /usr);
  -f, --force               force aptbox creation;
  --no-update               do not run "apt-get update" after creation;
  --repo=DIR                path to work repository directory;
  --repo-bin=DIR            binary packages destination directory,
                            overriding --repo option for binary packages;
  --repo-src=DIR            source packages destination directory,
                            overriding --repo option for source packages;
  --target=ARCH             target architecture of the work repository;
  -u, --update              run "apt-get update" after creation;
  --wait-lock               wait for workdir lock;
  --no-wait-lock            do not wait for workdir lock;
  --without-stuff           do not configure sources.list for the work repository;
  --with-stuff              configure sources.list for the work repository;
  -q, --quiet               try to be more quiet;
  -v, --verbose             print a message for each action;
  -V, --version             print program version and exit;
  -h, --help                show this text and exit.

Report bugs to https://bugzilla.altlinux.org/

EOF
	exit
}

TEMP=`getopt -n $PROG -o f,u,$getopt_common_opts -l apt-config:,apt-prefix:,force,no-lock,no-stuff,no-update,repo:,repo-bin:,repo-src:,target:,update,wait-lock,no-wait-lock,without-stuff,with-stuff,$getopt_common_longopts -- "$@"` ||
	show_usage
eval set -- "$TEMP"

force=
update=1
while :; do
	case "$1" in
		--apt-config)
			apt_config="$(opt_check_read "$1" "$2")"
			shift
			;;
		--apt-prefix)
			apt_prefix="$(opt_check_dir "$1" "$2")"
			shift
			;;
		-f|--force) force=1
			;;
		--no-lock) no_lock=1
			;;
		--no-update) update=
			;;
		--repo) shift; repo="$1"
			;;
		--repo-bin) shift; repo_bin="$1"
			;;
		--repo-src) shift; repo_src="$1"
			;;
		--target) shift; target="$1"
			[ -z "${target##[A-Za-z]*}" ] ||
				fatal "--target: $target: invalid architecture."
			;;
		-u|--update) update=1
			;;
		--wait-lock) lock_nowait=
			;;
		--no-wait-lock) lock_nowait=1
			;;
		--without-stuff|--no-stuff) no_stuff=1
			;;
		--with-stuff) no_stuff=
			;;
		--) shift; break
			;;
		*) parse_common_option "$1"
			;;
	esac
	shift
done

if [ -z "$workdir" ]; then
	# Exactly one argument.
	[ "$#" -ge 1 ] || show_usage 'Insufficient arguments.'
	[ "$#" -le 1 ] || show_usage 'Too many arguments.'
else
	# At most one argument.
	[ "$#" -le 1 ] || show_usage 'Too many arguments.'
fi

if [ "$#" -ge 1 ]; then
	workdir="$1"
	shift
fi
set_workdir

lock_workdir

[ -n "$no_stuff" ] ||
	make_repo
[ -n "$repo" ] || repo="$def_repo"
repo="$(readlink -fv -- "$repo")"

# does aptbox exist yet?
if [ -e aptbox -o -L aptbox ]; then
	[ -n "$force" ] || fatal "remove $aptbox first."
	[ -d aptbox ] || fatal "$aptbox: invalid pathname."

	# empty dir?
	if rmdir -- aptbox 2>/dev/null; then
		mkdir -m700 $verbose -- aptbox >&2
		cd aptbox
	else
		cd aptbox
		[ -d ./etc/apk -a -d ./var/cache/apk ] ||
			fatal "$aptbox: doesn't look valid."
	fi
else
	mkdir -m700 $verbose -- aptbox >&2
	cd aptbox
fi

verbose "Changed working directory to \`$aptbox'."

if [ -n "$unchecked_initroot_cache" ]; then
	cookie_file="$cache_dir/chroot/cookie"
	compressor_used="$cache_dir/chroot/compressor"
	aptbox_archive="$cache_dir/chroot/aptbox.tar"

	if [ -s "$cookie_file" -a -s "$compressor_used" -a -s "$aptbox_archive" ] &&
	   [ "$unchecked_initroot_cache" = "$(cat -- "$cookie_file")" ]; then
		compressor_prog=$(cat "$compressor_used")
		$compressor_prog -d < "$aptbox_archive" |
		tar -x &&
			verbose "Unpacked $aptbox_archive." ||
			fatal "Unpack of $aptbox_archive failed."
		exit 0
	fi
fi

# create apt/rpm skeleton directories.
mkdir -p $verbose -- \
	./var/cache/apk \
	>&2

# define apt variables.
prog_apk="${prog_apk:-apk.static}"
if [ -z "$apt_prefix" ]; then
	apt_libdir="$LD_LIBRARY_PATH"
else
	[ -d "$apt_prefix" ] ||
		fatal "$apt_prefix: directory not available."

	if printf %s "$apt_prefix" |LC_ALL=C grep -qs '[`"$\]'; then
		fatal "$apt_prefix: illegal symbols in apt prefix."
	fi

	slibdir="$(getconf SLIB ||:)"
	[ -n "$slibdir" ] || slibdir="lib"

	apt_libdir="$apt_prefix/$slibdir"
	[ -d "$apt_libdir" ] ||
		fatal "$apt_libdir: directory not available."

	if [ -n "$LD_LIBRARY_PATH" ]; then
		apt_libdir="$LD_LIBRARY_PATH:$apt_libdir"
	fi

	local n="$prog_apk"
		prog="$apt_prefix/bin/$n"
		[ -x "$prog" ] ||
			fatal "$prog: program not available."
		var="$(printf 'prog_%s' "$n" |tr - _)"
		eval "$var=\"$(quote_shell "$prog")\""
fi
if printf %s "$apt_libdir" |LC_ALL=C grep -qs '[`"$\]'; then
	fatal "$LD_LIBRARY_PATH: illegal symbols in LD_LIBRARY_PATH."
fi

# Create setarch wrapper.
setarch=
if setarch "${target:-$def_target}" true 2>/dev/null; then
	setarch="setarch \"$(quote_shell "${target:-$def_target}")\""
fi
cat >setarch <<__EOF__
#!/bin/sh -e
exec $setarch "\$@"
__EOF__
chmod $verbose a+x setarch >&2

# create aptbox version of ~/.rpmrc if necessary.
aptbox_home=
# FIXME:
current_arch="$def_target"
[ -n "$current_arch" ] ||
	current_arch="$(uname -m)"
[ "$current_arch" != "${target:-$def_target}" ] &&
	alternate_arch=1 ||
	alternate_arch=
if [ -n "$alternate_arch" ] &&
   true; then
	# FIXME later
	aptbox_home="$aptbox/home/user"
	for f in "$HOME/.rpmrc" "$HOME/.rpmmacros"; do
		[ ! -f "$f" ] ||
			install -pm600 $verbose -- "$f" "$aptbox_home/" >&2
	done
	echo "arch_compat: $current_arch: ${target:-$def_target}" >> "$aptbox_home/.rpmrc"
fi

# Create apt wrappers.
for n in apk; do
	cat >"$n" <<__EOF__
#!/bin/sh -e
${apt_libdir:+export LD_LIBRARY_PATH="$apt_libdir"}
${aptbox_home:+HOME="$aptbox_home"} \
exec $aptbox/setarch \
$(eval printf %s "$(printf '$prog_%s' "$n" |tr - _)") --root "$aptbox" --allow-untrusted "\$@"
FIXME: untrusted above
__EOF__
	verbose "created $n wrapper"
	chmod $verbose a+x "$n" >&2
done

cat >regenbasedir <<__EOF__
#!/bin/sh -ef
# Note that hasher uses rpm-dir method instead of genbasedir.
# Only use this script e.g. before uploading your repo to ftp.
mkdir -p "$repo"/${target:-$def_target}/base
genbasedir --topdir="$repo" --no-oldhashfile --bz2only --mapi --bloat ${target:-$def_target} hasher "\$@"
__EOF__
rm -f regenbasedir >&2

# create apk environment skeleton
"$aptbox/setarch" "$prog_apk" --repositories-file /dev/null --initdb --root "$aptbox" add \
  $([ -n "$verbose" ] || echo -qq)
rmdir "$aptbox"/{dev,proc} ||:
cp -f "$reps_file" etc/apk/repositories
ln -snf ../../var/cache/apk etc/apk/cache

echo "${repo_bin:-${repo:-$def_repo}/aports}" >> etc/apk/repositories

# create a new apk environment tree for use when chroot isn't yet created
mkdir -p tmp/{lib,var/lib}
ln -sf ../etc tmp/
ln -sf ../../var/cache tmp/var/
mv -f lib/apk tmp/lib/ 2>/dev/null ||:
mv -f var/lib/apk tmp/var/lib/ 2>/dev/null ||:

# finalize the main aptbox creation
mkdir -p ./lib ./var/lib
ln -sf    ../../chroot/lib/apk ./lib/
ln -sf ../../../chroot/var/lib/apk ./var/lib/

verbose "Created APK box in \`$aptbox'."

[ -z "$update" ] || "$aptbox/apk" --root "$aptbox"/tmp update $([ -n "$verbose" ] || echo -qq)
